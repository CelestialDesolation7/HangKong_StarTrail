# 星穹轨道 —— 开发规范与指南

## 版本历史
| 版本号 | 日期 | 描述 |
| --- | --- | --- |
| v1.0 | 2025-05-15 | 初始版本：包含代码规范、UI规范、性能优化和启动界面实现指南 |

## 目录
1. [开发环境配置](#开发环境配置)
2. [代码规范](#代码规范)
3. [项目结构规范](#项目结构规范)
4. [UI开发规范](#UI开发规范)
5. [性能优化指南](#性能优化指南)
6. [问题排查与解决流程](#问题排查与解决流程)
7. [版本控制工作流](#版本控制工作流)
8. [文档规范](#文档规范)
9. [测试规范](#测试规范)

## 开发环境配置

### 基本开发环境

- **操作系统**：Windows 10/11
- **IDE**：Visual Studio 2022 (任何版本均可，推荐Professional或Enterprise)
- **.NET SDK**：.NET 8.0 SDK
- **Git 客户端**：Git for Windows 或 GitHub Desktop
- **文档工具**：Markdown编辑器 (如VS Code或Typora)

### 必要的IDE插件

- **XAML Styler**：用于规范化XAML代码格式
- **ReSharper**（推荐）：代码质量分析和自动重构
- **CodeMaid**：代码清理和格式化
- **GitHub Extension for Visual Studio**：方便Git操作

### 依赖项管理

- 所有NuGet包应在项目级解决方案中统一管理
- 原则上使用最稳定版本，避免预览版本
- 更新依赖项前必须在开发分支上进行测试

### 环境初始化步骤

1. 克隆仓库：`git clone https://github.com/StarTrailTeam/HangKong_StarTrail.git`
2. 打开解决方案：`HangKong_StarTrail.sln`
3. 还原NuGet包：在解决方案资源管理器中右键选择"还原NuGet包"
4. 构建解决方案：按F6或使用"构建"->"构建解决方案"菜单

## 代码规范

### 命名约定

#### 通用命名规则

- **命名应具有描述性和意义**：避免使用简写，除非是广泛接受的约定
- **命名应使用英文**：所有代码元素使用英文命名，注释可使用中文
- **避免使用缩写**：除非是广泛接受的缩写（如UI, XML等）

#### 特定元素命名规则

| 元素 | 规则 | 示例 |
| --- | --- | --- |
| 命名空间 | Pascal命名法 | `HangKong_StarTrail.Core` |
| 类名 | Pascal命名法 | `StarSystemViewModel` |
| 接口 | I前缀 + Pascal命名法 | `IDataService` |
| 方法 | Pascal命名法 | `CalculateOrbit()` |
| 属性 | Pascal命名法 | `PlanetName` |
| 字段（私有） | _前缀 + camel命名法 | `_planetList` |
| 常量 | 全大写加下划线 | `MAX_STAR_COUNT` |
| 枚举类型 | Pascal命名法 | `PlanetType` |
| 枚举值 | Pascal命名法 | `GasGiant` |
| 事件 | Pascal命名法，动词为前缀 | `DataLoaded` |
| 事件处理器 | Pascal命名法，On前缀 | `OnDataLoaded` |
| 局部变量 | camel命名法 | `starCount` |
| 参数 | camel命名法 | `planetData` |
| XAML控件 | 控件类型 + 功能描述 | `LoadingProgressBar` |

### 代码注释规范

- 使用XML文档注释格式（///）
- 类、公共方法和属性必须添加注释
- 复杂的算法需要详细的实现说明
- 使用TODO, HACK, UNDONE标记待处理任务

```csharp
/// <summary>
/// 计算天体轨道位置
/// </summary>
/// <param name="mass">天体质量（kg）</param>
/// <param name="distance">与中心天体距离（m）</param>
/// <returns>轨道位置坐标</returns>
public Vector3 CalculateOrbitPosition(double mass, double distance)
    {
    // TODO: 优化大质量天体计算精度
    ...
}
```

### 代码组织规范

- 每个文件只包含一个主要类
- 命名空间与文件夹结构一致
- 类成员排序规则：
  1. 常量和静态字段
  2. 实例字段
  3. 构造函数和析构函数
  4. 属性
  5. 方法（按功能分组）
  6. 嵌套类型
- 相关功能应该在代码中彼此靠近

### MVVM模式规范

- 视图（View）只包含UI定义，避免代码后置
- 视图模型（ViewModel）处理所有UI逻辑和数据转换
- 模型（Model）专注于数据和业务规则
- 使用命令（ICommand）处理用户交互
- 使用数据绑定传递数据，避免直接操作控件

## 项目结构规范

### 解决方案结构

```
HangKong_StarTrail/
│
├── HangKong_StarTrail/              # 主项目
│   ├── Models/                      # 数据模型
│   ├── ViewModels/                  # 视图模型
│   ├── Views/                       # 视图
│   ├── Services/                    # 服务实现
│   ├── Common/                      # 公共工具和辅助类
│   └── Resources/                   # 资源文件
│
├── HangKong_StarTrail.Core/         # 核心库
│   ├── Interfaces/                  # 接口定义
│   ├── Services/                    # 服务接口和基础实现
│   └── Utilities/                   # 通用工具类
│
├── HangKong_StarTrail.Data/         # 数据访问层
│   ├── Repositories/                # 数据仓库
│   └── Services/                    # 数据服务
│
├── HangKong_StarTrail.Simulation/   # 模拟计算模块
│   ├── Physics/                     # 物理计算
│   └── Algorithms/                  # 算法实现
│
├── HangKong_StarTrail.Tests/        # 测试项目
│   ├── UnitTests/                   # 单元测试
│   └── IntegrationTests/            # 集成测试
│
└── docs/                            # 项目文档
    ├── dev/                         # 开发文档
    └── user/                        # 用户文档
```

### 资源组织规范

- **图像资源**：按功能分类组织到子文件夹
- **样式资源**：集中在StyleResources目录
- **本地化资源**：使用RESX文件，按语言分类
- **配置文件**：统一存放在Config目录

### XAML文件组织

- 资源字典按功能分割为多个文件
- 控件模板和样式统一管理
- 页面级资源置于页面内
- 全局资源置于App.xaml

## UI开发规范

### 布局规范

- 优先使用Grid进行复杂布局
- 避免深层嵌套（不超过5层）
- 使用合适的面板控件（StackPanel, WrapPanel等）
- 采用相对单位而非绝对像素
- 支持不同屏幕分辨率和DPI设置

### 样式与主题

- 所有视觉元素使用样式定义
- 避免硬编码颜色和尺寸
- 主题颜色在中央资源字典定义
- 支持明暗主题切换
- 遵循设计文档中的视觉规范

### 启动界面开发规范

#### 设计原则

- 保持简洁，突出科技感和宇宙主题
- 提供视觉反馈，让用户了解加载进度
- 启动时间控制在10秒以内，超过此时间必须显示进度
- 支持用户中断（如按ESC键取消启动）

#### 技术实现要点

1. **3D星体渲染**：
   - 使用低多边形模型确保快速加载
   - 旋转速度应适中，避免过快造成眩晕感
   - 使用合适的光照效果增强立体感

2. **粒子系统**：
   - 限制同时存在的粒子数量（建议<200个）
   - 粒子更新逻辑应轻量化，避免阻塞UI线程
   - 提供配置选项调整粒子数量，适应不同硬件能力

3. **加载进度显示**：
   - 进度条应有明确的百分比指示
   - 提供文本信息说明当前加载阶段
   - 加载时间超过3秒必须显示进度条

4. **资源管理**：
   - 启动界面资源单独打包，优先加载
   - 设置合理的加载阶段，核心功能优先
   - 使用异步方法加载大型资源

5. **用户交互**：
   - 加载完成后明确提示用户如何继续
   - 支持键盘和鼠标交互
   - 加载过程中提供取消选项

#### 启动流程规范

1. 应用程序启动 → 显示简单的加载画面（无需3D）
2. 初始化基础组件 → 显示完整启动界面（含3D元素）
3. 异步加载各模块 → 更新加载进度
4. 完成必要模块加载 → 显示"点击继续"提示
5. 用户交互 → 平滑过渡到主界面

### 交互设计规范

- 所有控件需有合适的交互反馈
- 操作响应时间不超过300ms
- 复杂操作提供进度指示
- 支持键盘导航和快捷键
- 符合Windows交互规范

### 可访问性规范

- 支持高对比度模式
- 控件元素大小适合点击
- 提供替代文本信息
- 支持键盘操作关键功能
- 考虑色盲用户需求

## 性能优化指南

### 性能目标

| 指标 | 目标值 | 最低要求 |
|------|--------|----------|
| 启动时间 | <5秒 | <10秒 |
| UI响应时间 | <100ms | <300ms |
| 帧率 | >60FPS | >30FPS |
| 内存占用 | <1GB | <2GB |
| 加载大型场景 | <3秒 | <8秒 |

### WPF性能优化技巧

1. **XAML优化**：
   - 减少元素嵌套深度
   - 使用可视化树剪裁技术（Virtualization）
   - 避免过多的绑定表达式
   - 合理使用CacheMode属性

2. **渲染优化**：
   - 使用BitmapCache提高渲染性能
   - 优化触发器和动画效果
   - 控制视觉树大小和复杂度
   - 谨慎使用半透明效果和阴影

3. **数据绑定优化**：
   - 使用ObservableCollection优化集合绑定
   - 避免在绑定中执行复杂计算
   - 合并PropertyChanged事件通知
   - 对大数据集使用虚拟化控件

4. **资源管理**：
   - 延迟加载非关键资源
   - 正确处理大型对象的生命周期
   - 使用弱引用缓存大型资源
   - 主动释放未使用的资源

### 3D渲染优化

1. **模型优化**：
   - 使用LOD（Level of Detail）技术
   - 简化远距离物体的几何体
   - 根据视距调整纹理细节
   - 使用法线贴图替代高精度网格

2. **渲染技术**：
   - 实现视锥体剔除
   - 使用实例化渲染相似对象
   - 优化着色器复杂度
   - 减少渲染状态切换

3. **纹理管理**：
   - 使用合适的纹理压缩格式
   - 实现纹理缓存和预加载
   - 按需生成和释放纹理资源
   - 使用mipmapping优化远距离渲染

### 内存管理

1. **对象池**：
   - 复用临时对象避免频繁创建
   - 实现简单对象池管理频繁使用的对象
   - 对于粒子系统必须使用对象池技术

2. **资源释放**：
   - 显式调用Dispose方法释放资源
   - 注意合理管理事件订阅和取消订阅
   - 大型资源使用后主动设为null
   - 定期执行GC.Collect()释放大型资源

3. **内存泄漏防范**：
   - 使用分析工具定期检查内存使用
   - 注意静态事件的订阅和取消
   - 避免循环引用
   - 使用弱引用避免不必要的对象存活

### 多线程与异步编程

1. **UI线程优化**：
   - 耗时操作移至后台线程
   - 避免长时间阻塞UI线程
   - 通过Dispatcher更新UI元素
   - 合并UI更新操作

2. **并行计算**：
   - 使用Task并行库处理计算密集型任务
   - 为大数据计算实现并行算法
   - 注意线程安全和资源竞争
   - 使用线程池避免过多线程创建

3. **异步模式**：
   - 正确使用async/await模式
   - 实现可取消的异步操作
   - 处理异常并提供用户反馈
   - 使用进度报告更新UI

### 启动性能优化

1. **冷启动优化**：
   - 延迟加载非必要模块
   - 使用预编译XAML（XamlReader.Load）
   - 预热关键对象和缓存
   - 优化程序集加载顺序

2. **资源优化**：
   - 减小初始资源包大小
   - 优先加载核心UI资源
   - 并行加载独立资源
   - 优化资源查找路径

3. **用户体验技巧**：
   - 快速显示启动界面营造响应感
   - 提供有意义的加载提示
   - 优先初始化用户可见部分
   - 实现流畅的启动动画

## 问题排查与解决流程

### 常见问题分类

1. **UI相关问题**：
   - 布局异常
   - 渲染错误
   - 样式加载失败
   - 动画卡顿

2. **性能问题**：
   - 启动缓慢
   - 内存占用高
   - 3D场景卡顿
   - UI响应延迟

3. **数据问题**：
   - 数据加载错误
   - 计算结果不准确
   - 绑定失效
   - 数据同步异常

4. **系统集成问题**：
   - 模块加载失败
   - 依赖项冲突
   - 资源路径错误
   - 配置读取错误

### 启动界面相关问题解决

#### 症状：启动界面加载缓慢
- **可能原因**：
  1. 3D模型过于复杂
  2. 资源文件过大
  3. 无效的加载阻塞

- **排查步骤**：
  1. 检查是否有同步加载大型资源
  2. 使用性能分析工具找出瓶颈
  3. 检查3D对象的多边形数量
  4. 检查启动序列中不必要的初始化

- **解决方案**：
  1. 简化3D模型或使用LOD技术
  2. 延迟加载非必要资源
  3. 确保UI更新在主线程中进行
  4. 改为异步加载序列

#### 症状：3D星体无法显示或显示异常
- **可能原因**：
  1. 3D几何体创建错误
  2. 渲染器初始化失败
  3. 资源路径错误
  4. 着色器兼容性问题

- **排查步骤**：
  1. 检查几何体创建代码
  2. 验证纹理和材质加载
  3. 检查3D相机设置
  4. 查看日志中的渲染错误

- **解决方案**：
  1. 使用更简单的几何体进行测试
  2. 确保资源路径正确且资源存在
  3. 调整相机参数确保可见性
  4. 提供兼容性回退方案

#### 症状：进度条更新不正确
- **可能原因**：
  1. 进度计算逻辑错误
  2. UI线程更新问题
  3. 异步操作未正确报告进度
  4. 绑定更新未触发

- **排查步骤**：
  1. 检查进度计算算法
  2. 确认进度更新在UI线程进行
  3. 检查异步任务的进度报告
  4. 验证值转换器和绑定方式

- **解决方案**：
  1. 修正进度计算比例
  2. 使用Dispatcher确保UI线程更新
  3. 添加进度更新日志点
  4. 校准进度报告与实际状态

### 问题报告规范

报告问题时应提供以下信息：

1. **问题描述**：简洁清晰描述问题现象
2. **复现步骤**：详细的重现问题的步骤
3. **期望行为**：正确的预期行为
4. **环境信息**：
   - 系统版本
   - 运行环境
   - 硬件配置
5. **截图或视频**：直观展示问题
6. **相关日志**：应用程序日志或异常堆栈

### 调试技巧

1. **XAML调试**：
   - 使用Live Visual Tree分析UI结构
   - 使用Snoop工具检查WPF属性
   - 启用XAML热重载加速UI调试

2. **性能分析**：
   - 使用Visual Studio性能分析器
   - 添加关键点性能计数器
   - 使用ETW跟踪分析事件

3. **内存分析**：
   - 使用Memory Profiler检测内存泄漏
   - 分析大对象堆情况
   - 比较不同时间点的堆快照

4. **日志分析**：
   - 添加结构化日志记录
   - 使用不同级别区分日志重要性
   - 记录关键性能节点的时间戳

## 版本控制工作流

### 分支策略

- **main**：主分支，始终保持可发布状态
- **develop**：开发分支，集成已完成功能
- **feature/***：功能分支，用于开发新功能
- **bugfix/***：缺陷修复分支
- **release/***：发布准备分支
- **hotfix/***：紧急修复分支

### 提交规范

提交信息格式：`<类型>: <简短描述>`

类型包括：
- **feat**：新功能
- **fix**：缺陷修复
- **docs**：文档更新
- **style**：代码格式化，无功能变化
- **refactor**：代码重构，无功能变化
- **perf**：性能优化
- **test**：测试相关
- **chore**：构建或工具变更

### 合并请求流程

1. 创建分支进行开发
2. 完成开发并进行自测
3. 提交合并请求（PR）
4. 进行代码审查
5. 解决反馈问题
6. 合并到目标分支

### 发布流程

1. 从develop分支创建release分支
2. 修复release分支中的问题
3. 完成测试后合并到main和develop
4. 在main分支上创建版本标签
5. 生成发布包

## 文档规范

### 代码文档

- 所有公共API必须有XML文档注释
- 复杂算法需要详细注释
- 更新代码时同步更新相关注释
- 使用文档生成工具创建API文档

### 技术文档

- 使用Markdown格式编写
- 按模块组织文档结构
- 包含示例代码和图表
- 文档与代码同步更新

### 用户文档

- 提供一致的文档结构
- 以用户视角编写
- 包含适当的截图和指引
- 使用简洁明了的语言

## 测试规范

### 单元测试

- 每个核心功能类应有对应测试类
- 测试覆盖率目标>80%
- 使用MSTest或NUnit框架
- 使用模拟框架隔离依赖

### UI测试

- 关键UI功能需要自动化测试
- 使用UI自动化框架
- 测试跨分辨率兼容性
- 验证键盘和鼠标交互

### 性能测试

- 定义关键性能指标和基线
- 实现自动化性能测试
- 在CI流程中进行性能回归测试
- 测试不同硬件配置下的性能

### 验收测试

- 基于用户场景设计测试用例
- 测试完整工作流程
- 验证与需求的一致性
- 包含边界条件和异常情况 